###dijkstra算法

参考视频中的动图更好

输入：一个图g和一个起始点s
输出：输出起始点到各个顶点的最短距离以及路径

####算法流程：

辅助数据结构：**最小索引堆iqp**，用保存目前完成了松池操作的顶点以及~~指向它的边的权重~~**s到各自顶点的目前的最短距**						     **离**，用于选取最短边。(和prim算法一样, **ipq与distTo对应**)，这些顶点是当前访问过(即进行过松池操作)							 但是还没有找到s到它的最短距离的顶点。
							 **数组distTo**，用于存储当前找到的s到达每个顶点的最短距离
							 **数组marked**，用于标记每个顶点是否找到了最短距离
							 **数组from**，每个顶点从s到它最短路径上，from保存**指向**这个顶点的**边的指针**.同时也表示顶点是否访问							 过，初始为空指针

~~~c++
// 针对起始点s，iqp、distTo、marked、from都进行相应的操作
s到自身的距离为0，令数组中distTo[s]=0，表示访问了s
marked[s] = true; //标记s，表示找到s的最短距离

while (!ipq.isEmpty()):
	在ipq中取出s到目前进行松池操作后的顶点的最短距离，假设为顶点v(第一次取出的是s)，即取出目前能抵达且未找到	最短距离的顶点v，则s到顶点v的最小距离就是这个距离。
    marked[v] = True; // 标记找到了顶点v的的最短距离
    // 对顶点v的未找到最短距离的相邻顶点进行松池操作
    遍历顶点v的邻边
        如果v的相邻顶点w没有找到最短边
        	如果顶点w没有访问过，即from[w]为空或者ipq中含有顶点w || 顶点w访问过但是当前s到顶点w的距离大				于s到顶点v的距离加上v到w的距离
        		// 对顶点w进行松池操作
        		distTo[w] = distTo[v] + v到w的距离
        		// 对最小堆索引中的边进行更新或者添加
        		如果最小索引堆中没有保存w顶点当前的最小距离（也可以是from[w]为空）
        			在ipq中添加w的当前最短路径为distTo[w]
        		如果最小索引堆中有保存w顶点当前的最小距离（也可以是from[w]不为空）
        			将ipq中序号为w的元素的值更新为distTo[w]
        		from[w] = *edge_vw; // 记录w来自边vw
                    
// ### 其它的函数
                    
函数1：返回从s点到w点的最短路径长度
函数2：判断从s点到w点是否联通
函数3：寻找从s到w的最短路径, 将整个路径经过的边存放在vec中
函数4：打印出从s点到w点的路径                    
        	
~~~

完成dijkstra算法后，s到各个顶点的最短距离保存在distTo中，每个顶点的最短路径上指向每个顶点的边的指针保存在from中。利用数组distTo和from可以得到各个顶点对应的最短路径

时间复杂度：elogv

**应用场景：**没有负权边的图，可以是有向图和无向图

**重点1：** ipq中保存的是s到各个顶点目前的距离，**每次从ipq中取出的是最短距离的顶点的序号，同时这个最短距离就是s到这个顶点的最短距离**，因为如果从其它顶点再到这个顶点，而不存在负权边，肯定比当前的最短距离长

**重点2：** **每次对从ipq中取出的最短距离指向的顶点的邻边的顶点进行松池操作**，只对那些没有找到最短距离的邻边的顶点进行松池操作。每次判断由前面找到的最短距离的顶点到这个相邻顶点的距离加上s到刚刚找到的最短距离是否小于当前s到邻边顶点的距离，或者这个相邻顶点没有访问过，满足上述两个条件则进行松池操作，更新s到这个相邻顶点的距离，同时更新ipq和from中相邻顶点序号的值

