优化Prim算法

**辅助数据结构**

bool *marked;                                           // 记录一个顶点是否被访问完成
IndexMinHeap<Weight> indexPQ;    // 用最小索引堆来保存横切边的权值，它将保存一个顶点以及指向这个顶点对应
																 // 的最小横切边的权重。而lazy prim的最小堆将保存所有横切边  vector<Edge<Weight>*> edgeTo;      // edgeTo这个vector的长度和顶点数一样，每个顶点/保存的是指向它的最小边的指																     针，每次访问一个顶点时更新最小边，当找到最小横切边时，可以根据索引在																      edgeTo中找到这个最小横切边。
vector<Edge<Weight>> minGenTree; // 保存最小生成树所有的边  

**思路**：对于每个已经访问的顶点，用一个中间向量edgeTo中对应元素保存**指向**该顶点的**最小权值的边的指针**，如果没有访问则为空指针。相对于lazy prim算法，优化的prim算法用一个索引最小堆ipq来保存**没有访问过的横切边**，这个横切边**指向**没有访问过的顶点 ，ipq中以这个没有访问过的顶点为序号，横切边的权值为值。当iqp为空时，算法终止。每次得到最小边的时候，访问这个最小边的另一个没有访问过的顶点。

visit(v)函数： 访问节点v相连接的未访问的相邻顶点, 和与之相连接的边, 放入最小索引堆中。如果和顶点v相连的顶点w没有访问过，直接将这条边的指针保存在edgeTo中并将边的权值**插入**最小堆iqp；如果顶点w已经访问过，但是v和w边的权值比当前w在edgeTo中对应的边的权值小，则将ipq中w对应的权值**更新**为v,w的边的权值，同时edgeTo中w对应元素为v,w边的指针

**核心点：**终止条件为ipq为空，另一个核心就是每次对最小横切边**指向**的顶点v进行访问并遍历它的邻边，这里最小堆中存放的是一个没有访问的顶点的权重。在visit函数中，如果一个顶点v在edgeTo中对应的最小边的权值比在当前访问顶点v'与顶点v连接的边的权重小，那么应该将顶点v对应的最小边替换成与v'相连的边，同时在iqp中**更新**顶点v'以及刚刚访问的这条边的权重。所以在后面从ipq中提取最小边的时候，ipq中所有权重对应的索引都是没有访问过的顶点，在找到最小边后，继续访问这个索引(顶点)即可，即遍历它的相邻顶点，更新edgeTo以及ipq。

**重点：**在迭代过程中更新edgeTo，ipq，以及marked，直到所以边迭代完成

**时间复杂度：**elogv



































