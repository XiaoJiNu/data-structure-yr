### 求图的连通分量

  思路：用一个模板类来完成，连通分量的个数用一个变量count来统计，用深度优先搜索来完成访问连通分量
  判断两个顶点是否相连：判断它们的id是否相同即可

~~~python
连通分量流程图，在模板类的构造函数中完成
遍历所有顶点
	如果一个顶点i没有访问过
    	对顶点i，用深度优先遍历访问完与顶点i相连的整个连通分量
        count++; # 访问完成一个连通分量，计数加1
        
深度优先搜索流程图
dfs(i):
    标记顶点i完成访问，记录顶点的id，也可以做对顶点i的其它操作
    迭代i的所有相邻顶点
    	如果i的相邻顶点j没有被访问过
        	递归调用深度优先遍历dfs(j)
        

二叉树的深度优先搜索流程图
dfsTree(i):
    判断是否到了叶结点(即它的左右节点为空)，如果到了叶节点，终止递归
	访问顶点i，也可以做对顶点i的其它操作
    如果i的左节点不为空，递归访问左节点
    如果i的右节点不为空，递归访问右节点
    

~~~

![image-20200720091333653](C:\Users\YR\AppData\Roaming\Typora\typora-user-images\image-20200720091333653.png)

​																								图1

以图1为例，深度优先搜索流程如下

访问顶点1 ----------1                                     
迭代1的相邻顶点2，3，4
由于顶点2没有访问过，递归访问顶点2 ----------2
迭代2的相邻顶点5  
由于顶点5没有访问过，递归访问顶点5，由于顶点2没有其它相邻顶点，返回顶点2那一层 ----------5
由于顶点2没有其它相邻顶点，返回顶点1那一层
顶点1的相邻点2已经访问过，下一次访问顶点3 ----------3
迭代顶点3的相邻顶点6
由于顶点6没有访问过，递归访问顶点6，由于顶点6没有其它相邻顶点，返回顶点3那一层 ----------6
由于顶点3没有其它相邻顶点，返回顶点1那一层
顶点1的相邻点2，3已经访问过，下一次访问顶点4 ----------4
由于4没有相邻顶点，退加顶点1那一层，由于1的相邻顶点已经迭代完成，所以终止深度优先搜索



#### 图和二叉树的深度优先搜索的区别

​		图的深度优先搜索是迭代当前顶点的所有相邻顶点，再对每个相邻顶点进行递归访问，在决定是否访问一个相邻点的时候，**需要判断这个相邻顶点是否被访问过，因为图可能存在环，而且树的存储结构和图的存储结构不同**
​		二叉树不可能存在环，所以它不需要判断每个节点是否访问过。同时，二叉树由于每个节点最多只有两个子节点，而且树的存储结构和图的存储结构不同，所以不需要迭代节点的所有子结点，只需要判断节点的左右子节点是否存在，然后递归不为空的子节点