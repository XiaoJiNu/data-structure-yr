### 求无权图的原点到一个顶点的最短路径

问题：给定一个无权图，求出图的原点到任意一个顶点的最短路径

思路：

​		思路和深度优先遍历类似，只是换成了广度优先遍历
​		1 依然用一个类Path来完成。在初始化类的时候就给定图的原点，同时用**广度优先遍历**访问与原点相连的所有顶点，用一个向量visited来记录这些访问过的点，并用一个大小为顶点数量的数组from来记录遍历时每个顶点是从哪个顶点过来的。(**from数组大小为顶点数量，from[i]表示顶点i的上一层相连顶点序号是from[i]，所以每次可以得到i的上一层相连顶点序号，最终直到from[i]==-1终止查找，因为第一个顶点的值from[0]=-1**)。同时，为了直接得到一个顶点到原点的最短路径距离，用数组**order**来记录每个顶点距离原点的层数，~~当前遍历层数用一个变量**currentLayerNum**来。~~原点所处层数为0，然后在访问每个顶点时，它的层数也即order中存储的数据，可以用**这个顶点上一层相连的顶点的层数+1(即上一层相连顶点的order数据+1得到)**
​		2 然后再用一个函数来找到一个顶点w与原点之间的路径，因为from记录的是前一层相连顶点序号，所以此时将路径放入栈中，然后再将栈中的元素放入vector，得到从原点到w的路径。

#### 深度优先遍历流程图

~~~c++
bfs(int i):
    创建一个队列
    将原点i入队
    order[i] = 0;
    while(队列不为空)
        取出原点的值
        弹出原点
        遍历原点的相连顶点
            如果相连顶点j没有访问过
                将顶点j入队
                记录顶点j已访问,visited[j] = true;
                记录顶点j的前一层顶点为i, from[j] = i;
                // 记录顶点j距离原点的序号，order[j] = currentLayerNum;  错误
        		记录顶点j的层数，order[j] = order[i] + 1;
~~~